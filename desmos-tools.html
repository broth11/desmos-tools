<!DOCTYPE html>
<html>
<head>
    <script src="https://www.desmos.com/api/v1.11/calculator.js?apiKey=7f6b13663be9401baca080ba3b371ab4"></script>
    <style>
        body { margin: 0; padding: 0; }
        #calculator { width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <div id="calculator"></div>
    <script>
        const params = new URLSearchParams(window.location.search);
        
        const calculator = Desmos.GraphingCalculator(
            document.getElementById('calculator'),
            {
                expressionsCollapsed: params.get('hideExpressions') === 'true',
                settingsMenu: params.get('settings') !== 'false',
                zoomButtons: params.get('zoom') !== 'false',
                expressions: params.get('showExpressions') !== 'false',
                lockViewport: params.get('lockViewport') === 'true',
                degreeMode: params.get('angleMode') === 'degrees',
                polarMode: params.get('polarMode') === 'true',
                fontSize: params.get('fontSize') ? parseInt(params.get('fontSize')) : undefined
            }
        );

        const expressions = params.get('expr');
        
        if (expressions) {
            const exprList = expressions.split(';');
            
            exprList.forEach((expr, index) => {
                const sliderMatch = expr.match(/(.+)=(.+)\[(.+),(.+)(?:,(.+))?\]/);
                
                if (sliderMatch) {
                    calculator.setExpression({
                        id: `expr${index}`,
                        latex: `${sliderMatch[1]}=${sliderMatch[2]}`,
                        sliderBounds: {
                            min: parseFloat(sliderMatch[3]),
                            max: parseFloat(sliderMatch[4]),
                            step: sliderMatch[5] ? parseFloat(sliderMatch[5]) : undefined
                        }
                    });
                } else {
                    calculator.setExpression({
                        id: `expr${index}`,
                        latex: expr.trim()
                    });
                }
            });
        }

        // Tables - format: table=x1,y1;x2,y2;x3,y3
        const tableData = params.get('table');
        if (tableData) {
            const points = tableData.trim().split(';').map(pair => {
                const [x, y] = pair.trim().split(',');
                return { x: parseFloat(x), y: parseFloat(y) };
            });
            
            const xValues = points.map(p => p.x).join(',');
            const yValues = points.map(p => p.y).join(',');
            
            calculator.setExpression({
                id: 'table_x',
                latex: `x_1=[${xValues}]`
            });
            calculator.setExpression({
                id: 'table_y',
                latex: `y_1=[${yValues}]`
            });
            
            // Plot the points (x_1, y_1)
            calculator.setExpression({
                id: 'table_points',
                latex: `(x_1,y_1)`,
                pointStyle: Desmos.Styles.POINT
            });
        }
        // Labels - format: labels=Label1;Label2;Label3
            const labels = params.get('labels');
            if (labels && tableData) {
                const labelList = labels.split(';');
                const points = tableData.trim().split(';').map((pair, index) => {
                    const [x, y] = pair.trim().split(',');
                    return { x: parseFloat(x), y: parseFloat(y), label: labelList[index] };
                });
                
                // Remove the generic points expression
                calculator.removeExpression({ id: 'table_points' });
                
                // Add individual labeled points
                points.forEach((point, index) => {
                    if (point.label) {
                        calculator.setExpression({
                            id: `labeled_point_${index}`,
                            latex: `(${point.x},${point.y})`,
                            label: point.label,
                            showLabel: true,
                            pointStyle: Desmos.Styles.POINT
                        });
                    }
                });
            }
        
        // Regression - pass exactly as provided in URL (don't modify)
        const regression = params.get('regression');
        if (regression) {
            calculator.setExpression({
                id: 'regression',
                latex: decodeURIComponent(regression)
            });
        }

        const scale = params.get('scale') ? parseFloat(params.get('scale')) / 100 : 1;

        if (params.get('xmin')) {
            calculator.setMathBounds({
                left: parseFloat(params.get('xmin')) * scale,
                right: parseFloat(params.get('xmax')) * scale,
                bottom: parseFloat(params.get('ymin')) * scale,
                top: parseFloat(params.get('ymax')) * scale
            });
        }

        // Logarithmic axes
        if (params.get('xAxisLog') === 'true') {
            calculator.updateSettings({ xAxisLog: true });
        }
        if (params.get('yAxisLog') === 'true') {
            calculator.updateSettings({ yAxisLog: true });
        }

        // Axis numbers visibility
        if (params.get('xAxisNumbers') === 'false') {
            calculator.updateSettings({ xAxisNumbers: false });
        }
        if (params.get('yAxisNumbers') === 'false') {
            calculator.updateSettings({ yAxisNumbers: false });
        }

        const xstep = params.get('xstep');
        const ystep = params.get('ystep');
        
        if (xstep || ystep) {
            calculator.updateSettings({
                xAxisStep: xstep ? parseFloat(xstep) * scale : undefined,
                yAxisStep: ystep ? parseFloat(ystep) * scale : undefined
            });
        }

        const piStep = params.get('piStep');
        if (piStep) {
            const step = (Math.PI / parseFloat(piStep)) * scale;
            calculator.updateSettings({
                xAxisStep: step
            });
        }

        // Grid control - major only (no minor grid lines)
if (params.get('majorGridOnly') === 'true') {
    calculator.updateSettings({ 
        showGrid: true,
        xAxisMinorSubdivisions: 1,
        yAxisMinorSubdivisions: 1
    });
}
    </script>
</body>
</html>
