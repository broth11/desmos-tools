<!DOCTYPE html>
<html>
<head>
    <title>Desmos Dynamic Geometry Builder</title>
    <script src="https://www.desmos.com/api/v1.10/calculator.js?apiKey=dcb31709b452b1cf9dc26972add0fda6"></script>
    <style>
        body { margin: 0; padding: 0; font-family: sans-serif; }
        #geometry { width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <div id="geometry"></div>
    <script>
        // Initialize Desmos and URL parser
        const params = new URLSearchParams(window.location.search);
        const geometry = Desmos.Geometry(document.getElementById('geometry'));

        let exprCounter = 0;

        // === HELPER FUNCTIONS ===

        function getNextId(prefix = 'expr') {
            return `${prefix}_${exprCounter++}`;
        }

        function processParameter(paramName, callback) {
            const paramValue = params.get(paramName);
            if (paramValue) {
                paramValue.split(';').forEach(item => {
                    try {
                        const parts = item.trim().split(',');
                        callback(parts, item.trim()); // Pass both parts and original item
                    } catch (e) {
                        console.error(`Error processing parameter '${paramName}' with value '${item}':`, e);
                    }
                });
            }
        }

        // === DEFAULTS & INITIAL SETUP ===
        
        if (params.get('hide_origin') !== 'true') {
            geometry.setExpression({ id: 'origin', latex: 'O=(0,0)', label: 'O', showLabel: true, color: Desmos.Colors.BLACK, pointStyle: Desmos.Styles.OPEN });
        }

        // === SLIDERS & DYNAMIC VARIABLES ===

        // FINAL "PRIMING" SLIDER HANDLER
        processParameter('slider', (parts) => {
            const [name, val, min, max, step] = parts;
            const sliderId = `slider_${name}_${getNextId()}`;

            // Step 1: Create a simple placeholder expression.
            geometry.setExpression({
                id: sliderId,
                latex: `${name}=0`
            });

            // Step 2: After a minimal delay, overwrite the placeholder with the full definition.
            setTimeout(() => {
                geometry.setExpression({
                    id: sliderId, // Use the same ID to overwrite
                    latex: `${name}=${parseFloat(val)}`,
                    slider: {
                        min: parseFloat(min),
                        max: parseFloat(max),
                        step: parseFloat(step)
                    }
                });
            }, 1); // 1ms delay
        });

        processParameter('expression', (parts, originalItem) => {
            geometry.setExpression({ id: getNextId('expression'), latex: originalItem });
        });

        // === POINT DEFINITIONS ===

        processParameter('point', (parts) => {
            const [name, x, y] = parts;
            geometry.setExpression({ id: `point_${name}`, latex: `${name}=(${x},${y})`, label: name, showLabel: true, color: Desmos.Colors.RED });
        });
        
        processParameter('gpoint', (parts) => {
            setTimeout(() => {
                const [name, xExpr, yExpr] = parts;
                geometry.setExpression({
                    id: `gpoint_${name}`,
                    latex: `${name}=(${xExpr},${yExpr})`,
                    label: name,
                    showLabel: true,
                    color: Desmos.Colors.PURPLE
                });
            }, 10);
        });

        // === LINES, SEGMENTS, VECTORS ===
        
        processParameter('line', (parts) => geometry.setExpression({ id: getNextId('line'), latex: `\\operatorname{line}(${parts[0]},${parts[1]})`, color: Desmos.Colors.BLUE }));
        processParameter('segment', (parts) => geometry.setExpression({ id: getNextId('segment'), latex: `\\operatorname{segment}(${parts[0]},${parts[1]})`, color: Desmos.Colors.GREEN }));
        processParameter('ray', (parts) => geometry.setExpression({ id: getNextId('ray'), latex: `\\operatorname{ray}(${parts[0]},${parts[1]})`, color: Desmos.Colors.BLUE }));
        processParameter('vector', (parts) => geometry.setExpression({ id: getNextId('vector'), latex: `\\operatorname{vector}(${parts[0]},${parts[1]})`, color: Desmos.Colors.PURPLE }));

        // === GEOMETRIC CONSTRUCTIONS ===
        
        processParameter('midpoint', ([name, p1, p2]) => geometry.setExpression({ id: getNextId('midpoint'), latex: `${name}=\\operatorname{midpoint}(${p1},${p2})`, label: name, showLabel: true, color: Desmos.Colors.ORANGE }));
        processParameter('perpendicular', ([name, point, p1_line, p2_line]) => geometry.setExpression({ id: getNextId('perp'), latex: `${name}=\\operatorname{perpendicular}(${point},\\operatorname{line}(${p1_line},${p2_line}))`, color: Desmos.Colors.GREEN }));
        processParameter('parallel', ([name, point, p1_line, p2_line]) => geometry.setExpression({ id: getNextId('parallel'), latex: `${name}=\\operatorname{parallel}(${point},\\operatorname{line}(${p1_line},${p2_line}))`, color: Desmos.Colors.BLUE }));
        processParameter('perp_bisector', ([name, p1, p2]) => geometry.setExpression({ id: getNextId('p_bisector'), latex: `${name}=\\operatorname{perpendicularbisector}(${p1},${p2})`, color: Desmos.Colors.PURPLE }));
        processParameter('angle_bisector', ([name, p1, v, p2]) => geometry.setExpression({ id: getNextId('a_bisector'), latex: `${name}=\\operatorname{anglebisector}(${p1},${v},${p2})`, color: Desmos.Colors.ORANGE }));
        processParameter('centroid', ([name, p1, p2, p3]) => geometry.setExpression({ id: getNextId('centroid'), latex: `${name}=\\operatorname{centroid}(${p1},${p2},${p3})`, label: name, showLabel: true, color: Desmos.Colors.ORANGE, pointStyle: Desmos.Styles.CROSS }));

        // === SHAPES & CURVES ===
        
        processParameter('polygon', (parts) => geometry.setExpression({ id: getNextId('polygon'), latex: `\\operatorname{polygon}(${parts.join(',')})`, fillOpacity: 0.2, color: Desmos.Colors.GREEN }));
        processParameter('circle', ([name, center, radius]) => geometry.setExpression({ id: getNextId('circle'), latex: `\\operatorname{circle}(${center},${radius})`, color: Desmos.Colors.PURPLE }));
        processParameter('parabola', ([name, vertex, focus]) => geometry.setExpression({ id: getNextId('parabola'), latex: `${name}=\\operatorname{parabola}(${vertex},${focus})`, color: Desmos.Colors.BLUE }));

        // === ANGLES & TRANSFORMATIONS ===
        
        processParameter('angle', (parts) => {
            const latex = parts.length === 4 ? `${parts[0]}=\\operatorname{angle}(${parts[1]},${parts[2]},${parts[3]})` : `\\operatorname{angle}(${parts[0]},${parts[1]},${parts[2]})`;
            geometry.setExpression({ id: getNextId('angle'), latex: latex, color: Desmos.Colors.ORANGE });
        });
        
        processParameter('reflect', ([obj, p1_line, p2_line]) => geometry.setExpression({ id: getNextId('reflect'), latex: `\\operatorname{reflect}(${obj},\\operatorname{line}(${p1_line},${p2_line}))`, lineStyle: Desmos.Styles.DASHED }));
        processParameter('rotate', ([obj, center, deg]) => geometry.setExpression({ id: getNextId('rotate'), latex: `\\operatorname{rotate}(${obj},${deg}^{\\circ},${center})`, lineStyle: Desmos.Styles.DASHED }));
        processParameter('dilate', ([obj, center, scale]) => geometry.setExpression({ id: getNextId('dilate'), latex: `\\operatorname{dilate}(${obj},${scale},${center})`, lineStyle: Desmos.Styles.DASHED }));

        // === LABELS & TEXT ===
        
        processParameter('text', (parts) => {
            const [x, y] = parts;
            const content = parts.slice(2).join(',');
            geometry.setExpression({ id: getNextId('text'), latex: `(${x},${y})`, label: content, showLabel: true, pointOpacity: 0, color: Desmos.Colors.BLACK });
        });

        // === GLOBAL DISPLAY SETTINGS (Applied last) ===
        
        const settings = {};
        if (params.get('grid') === 'false') settings.showGrid = false;
        if (params.get('axes') === 'false') settings.showAxes = false;
        if (params.get('angle_mode') === 'degrees') settings.degreeMode = true;
        if (params.get('projector_mode') === 'true') settings.projectorMode = true;
        if (params.get('lock_viewport') === 'true') settings.lockViewport = true;
        geometry.updateSettings(settings);

        if (params.has('xmin')) {
            geometry.setMathBounds({
                left: parseFloat(params.get('xmin')), right: parseFloat(params.get('xmax')),
                bottom: parseFloat(params.get('ymin')), top: parseFloat(params.get('ymax'))
            });
        }
        
        console.log("Desmos Dynamic Geometry Builder initialized.");
    </script>
</body>
</html>
