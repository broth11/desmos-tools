<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Desmos Dynamic Builder</title>
  <script src="https://www.desmos.com/api/v1.10/calculator.js?apiKey=dcb31709b452b1cf9dc26972add0fda6"></script>
  <style>
    body { margin: 0; padding: 0; }
    #calculator { width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <div id="calculator"></div>
  <script>
    const elt = document.getElementById('calculator');
    const calculator = Desmos.GraphingCalculator(elt, {
      expressions: true,
      settingsMenu: true,
      projectorMode: false,
      zoomButtons: true,
      expressionsCollapsed: false,
      keypad: true
    });

    const params = new URLSearchParams(window.location.search);
    const config = params.get('config');

    // ✅ FIXED: emit a SINGLE backslash; also collapse accidental doubles
    function toDesmosLatex(s = '') {
      if (typeof s !== 'string') return s;

      // If user provided backslashes already, normalize multiple "\" to one
      s = s.replace(/\\{2,}(?=[a-zA-Z])/g, '\\');

      const fns = [
        'sin','cos','tan','sec','csc','cot',
        'asin','acos','atan',
        'sinh','cosh','tanh',
        'ln','log'
      ];
      for (const fn of fns) {
        // bare fn(  -> \fn(
        s = s.replace(new RegExp(`(?<!\\\\)\\b${fn}\\s*\\(`, 'g'), '\\' + fn + '(');
        // any number of leading backslashes -> exactly one
        s = s.replace(new RegExp(`\\\\+${fn}\\s*\\(`, 'g'), '\\' + fn + '(');
      }

      // pi -> \pi (when not already escaped)
      s = s.replace(/(?<!\\)\bpi\b/g, '\\pi');

      // sqrt(x) -> \sqrt{x} (basic form)
      s = s.replace(/(?<!\\)\bsqrt\s*\(\s*([^()]+?)\s*\)/g, '\\sqrt{$1}');

      // degree symbol -> ^\circ
      s = s.replace(/(\^\s*)?°/g, '^\\circ');

      return s;
    }

    // Base state
    const state = {
      version: 11,
      graph: { degreeMode: false }, // radians by default
      expressions: { list: [] }
    };

    if (config) {
      const featureMap = {
        slider(parts) {
          const [name, val, min, max, step] = parts;
          return {
            type: 'expression',
            latex: `${name}=${val}`,
            slider: { min, max, step, hardMin: true, hardMax: true }
          };
        },
        point(parts) {
          const [name, ...coords] = parts;
          const [x = '', y = ''] = coords;
          return {
            type: 'expression',
            latex: `${name}=(${toDesmosLatex(x)},${toDesmosLatex(y)})`,
            showLabel: true
          };
        },
        segment(parts) {
          const [p1, p2] = parts;
          return {
            type: 'expression',
            latex: `((1-t)${p1}.x+t${p2}.x,(1-t)${p1}.y+t${p2}.y)`,
            parametricDomain: { min: '0', max: '1' }
          };
        },
        expression(parts) {
          const raw = parts.join(',');
          return { type: 'expression', latex: toDesmosLatex(raw) };
        }
      };

      const definitions = config.split(';');
      definitions.forEach(def => {
        try {
          const [feature, paramsStr] = def.split('=');

          // global setting
          if (feature === 'degree_mode') {
            state.graph.degreeMode = (paramsStr === 'true');
            return;
          }

          const paramsArr = paramsStr.split(',');
          const handler = featureMap[feature] || featureMap['expression'];
          const expressionObject = handler(paramsArr);
          state.expressions.list.push(expressionObject);
        } catch (e) {
          console.error('Could not parse definition:', def, e);
        }
      });

      requestAnimationFrame(() => {
        calculator.setState(state);
        console.log('Desmos state loaded from config.', state);
      });
    }
  </script>
</body>
</html>
