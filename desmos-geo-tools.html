<!DOCTYPE html>
<html>
<head>
    <title>Desmos Dynamic Builder</title>
    <script src="https://www.desmos.com/api/v1.10/calculator.js?apiKey=dcb31709b452b1cf9dc26972add0fda6"></script>
    <style>
        body { margin: 0; padding: 0; }
        #calculator { width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <div id="calculator"></div>
    <script>
        const elt = document.getElementById('calculator');
        const calculator = Desmos.GraphingCalculator(elt);
        const params = new URLSearchParams(window.location.search);
        const config = params.get('config');

        let exprCounter = 0;
        function getNextId() { return `expr_${exprCounter++}`; }

        if (config) {
            const definitions = config.split(';');

            // --- GLOBAL SETTINGS ---
            let settings = {};
            const degreeModeDef = definitions.find(d => d.startsWith('degree_mode='));
            if (degreeModeDef) {
                settings.degreeMode = (degreeModeDef.split('=')[1] === 'true');
            }
            calculator.updateSettings(settings);

            // --- EXPRESSION HANDLERS ---
            const featureMap = {
                slider: (parts) => {
                    const [name, val, min, max, step] = parts;
                    calculator.setExpression({
                        id: getNextId(),
                        latex: `${name}=${val}`,
                        slider: { min, max, step, hardMin: true, hardMax: true }
                    });
                },
                point: (parts) => {
                    const [name, ...coords] = parts;
                    const latex = `${name}=(${coords.join(',')})`;
                    const isDynamic = coords.some(c => /[a-zA-Z]/.test(c));
                    
                    const expr = { id: name, latex: latex, showLabel: true };

                    if (isDynamic) {
                        // Delay dynamic points to ensure dependencies (like sliders) are ready
                        setTimeout(() => calculator.setExpression(expr), 10);
                    } else {
                        calculator.setExpression(expr);
                    }
                },
                segment: (parts) => {
                    const [p1, p2] = parts;
                    calculator.setExpression({
                        id: getNextId(),
                        latex: `((1-t)${p1}.x+t${p2}.x,(1-t)${p1}.y+t${p2}.y)`,
                        parametricDomain: { min: '0', max: '1' }
                    });
                },
                expression: (parts) => {
                    calculator.setExpression({ id: getNextId(), latex: parts.join(',') });
                }
            };

            definitions.forEach(def => {
                try {
                    const [feature, paramsStr] = def.split('=');
                    if (feature === 'degree_mode') return; // Skip settings
                    
                    const paramsArr = paramsStr.split(',');
                    const handler = featureMap[feature] || featureMap['expression'];
                    handler(paramsArr);

                } catch (e) {
                    console.error("Could not parse definition:", def, e);
                }
            });
        }
    </script>
</body>
</html>
